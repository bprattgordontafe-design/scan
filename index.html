<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Webcam 3-shot → PDF</title>

  <style>
    :root { --accent:#1e88e5; --bg:#0f1720; --card:#0b1220; color-scheme: dark; }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071025 0%, #021226 100%);color:#e6eef8}
    .card{width:980px;max-width:95vw;background:rgba(10,14,20,0.55);border-radius:12px;padding:18px;box-shadow:0 8px 30px rgba(0,0,0,0.6);display:grid;grid-template-columns:1fr 320px;gap:18px}
    .left{display:flex;flex-direction:column;align-items:center;gap:12px}
    .video-wrap{position:relative;background:#000;border-radius:8px;overflow:hidden;width:100%;aspect-ratio:16/9;display:flex;align-items:center;justify-content:center}
    video{width:100%;height:100%;object-fit:cover;display:block}
    .overlay{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
      pointer-events:none;font-weight:700;font-size:72px;color:rgba(255,255,255,0.94);text-shadow:0 4px 18px rgba(0,0,0,0.7)
    }
    .controls{display:flex;gap:12px;align-items:center}
    #startBtn{appearance:none;border:0;background:linear-gradient(180deg,var(--accent),#125ddc);color:white;padding:18px 28px;border-radius:10px;font-size:20px;cursor:pointer;box-shadow:0 6px 20px rgba(30,136,229,0.18)}
    #startBtn[disabled]{opacity:0.5;cursor:not-allowed}
    .note{font-size:13px;color:#c9d7ee;opacity:0.9}
    .right{display:flex;flex-direction:column;gap:10px}
    .thumbs{display:grid;grid-template-columns:repeat(1,1fr);gap:8px}
    .thumb{background:linear-gradient(180deg,#071233,#021226);padding:8px;border-radius:8px;display:flex;gap:8px;align-items:center}
    .thumb img{width:86px;height:64px;object-fit:cover;border-radius:4px}
    .thumb .meta{font-size:13px;color:#cfe3ff}
    .status{font-size:14px;color:#dbeafe}
    @media (max-width:900px){ .card{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="card" role="main">
    <div class="left">
      <div class="video-wrap" aria-live="polite">
        <video id="video" autoplay playsinline></video>
        <div id="countdown" class="overlay" aria-hidden="true" style="display:none">3</div>
      </div>

      <div class="controls" style="margin-top:8px">
        <button id="startBtn">Take 3 Photos → PDF</button>
        <div class="note">Click the button once. Allow camera access. Works best in Chrome/Edge/Firefox on Windows via HTTPS.</div>
      </div>

      <div style="margin-top:8px" class="status" id="status">Status: idle</div>
    </div>

    <div class="right">
      <div style="font-weight:700">Captured photos</div>
      <div class="thumbs" id="thumbs">
        <div class="thumb"><div style="width:86px;height:64px;background:#091028;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#6b7f9f">No photos yet</div></div>
      </div>
      <div style="margin-top:auto;font-size:12px;color:#9fb7e6">
        Notes:
        <ul style="margin:6px 0 0 18px;padding:0">
          <li>GitHub Pages serves over HTTPS, so camera permission will work.</li>
          <li>If IT blocks getUserMedia, nothing in the page can override that — they control browser policies.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- jsPDF (UMD build) -->
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
  (function () {
    const startBtn = document.getElementById('startBtn');
    const video = document.getElementById('video');
    const countdownEl = document.getElementById('countdown');
    const statusEl = document.getElementById('status');
    const thumbs = document.getElementById('thumbs');

    let stream = null;

    function logStatus(txt) {
      statusEl.textContent = 'Status: ' + txt;
    }

    function sleep(ms) { return new Promise(r=>setTimeout(r, ms)); }

    async function openCamera() {
      const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: "user" }, audio: false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
      return;
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
    }

    // Short beep using WebAudio (user gesture required; we'll call this during the click sequence)
    function beep(duration = 140, freq = 950, vol = 0.06) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration/1000);
        setTimeout(() => { o.stop(); ctx.close(); }, duration + 20);
      } catch (e) {
        // audio may be blocked; ignore
        console.warn('beep audio failed', e);
      }
    }

    // Show overlay countdown (3..2..1) and return when finished
    async function countdown(seconds = 3) {
      countdownEl.style.display = 'flex';
      for (let s = seconds; s >= 1; s--) {
        countdownEl.textContent = s;
        await sleep(1000);
      }
      // Play a short beep on "0"
      countdownEl.textContent = '●';
      beep(160, 1000, 0.08);
      await sleep(280);
      countdownEl.style.display = 'none';
    }

    function captureFrame() {
      const w = video.videoWidth;
      const h = video.videoHeight;
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, w, h);
      return canvas.toDataURL('image/jpeg', 0.95);
    }

    function addThumb(dataUrl, idx) {
      // clear placeholder if first
      if (thumbs.children.length === 1 && thumbs.children[0].innerText && thumbs.children[0].innerText.includes('No photos yet')) {
        thumbs.innerHTML = '';
      }

      const el = document.createElement('div');
      el.className = 'thumb';
      const img = document.createElement('img');
      img.src = dataUrl;
      img.alt = 'Capture ' + idx;
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `Photo ${idx}<br/><small>${new Date().toLocaleTimeString()}</small>`;
      el.appendChild(img);
      el.appendChild(meta);
      thumbs.appendChild(el);
    }

    async function createPDFFromDataURLs(dataURLs) {
      const { jsPDF } = window.jspdf;
      if (!jsPDF) throw new Error('jsPDF not found');

      // Use first image size to set page dims in pixels
      const img = new Image();
      img.src = dataURLs[0];
      await new Promise(res => img.onload = res);
      const w = img.naturalWidth;
      const h = img.naturalHeight;

      const pdf = new jsPDF({ unit: 'px', format: [w, h] });

      for (let i = 0; i < dataURLs.length; i++) {
        if (i > 0) pdf.addPage([w, h]);
        pdf.addImage(dataURLs[i], 'JPEG', 0, 0, w, h);
      }

      // Trigger browser Save-as dialog. The filename suggestion is provided but user can rename.
      pdf.save('webcam-photos.pdf');
    }

    startBtn.addEventListener('click', async function () {
      startBtn.disabled = true;
      try {
        logStatus('Requesting camera permission...');
        await openCamera();
      } catch (err) {
        console.error(err);
        logStatus('Camera permission denied or no camera available.');
        alert('Unable to access camera. Make sure you allowed permission and the page is served over HTTPS (GitHub Pages).');
        startBtn.disabled = false;
        return;
      }

      logStatus('Camera ready. Starting sequence...');
      const captures = [];

      try {
        for (let i = 1; i <= 3; i++) {
          logStatus(`Preparing shot ${i}...`);
          // 3 second delay with visible countdown and beep at the end
          await countdown(3);   // shows 3..2..1 then beep then small delay
          // capture
          const data = captureFrame();
          captures.push(data);
          addThumb(data, i);
          logStatus(`Captured photo ${i}`);
          // If not last, wait an extra 500ms so user sees thumbnail update before next countdown (keeps rhythm)
          if (i < 3) await sleep(500);
        }

        logStatus('All photos taken. Generating PDF...');
        // stop camera early to free device/LED
        stopCamera();

        await createPDFFromDataURLs(captures);
        logStatus('PDF generated. Save dialog should appear.');
      } catch (err) {
        console.error(err);
        logStatus('Error during capture: ' + (err && err.message ? err.message : String(err)));
        alert('An error occurred: ' + (err && err.message ? err.message : String(err)));
      } finally {
        startBtn.disabled = false;
        // ensure camera stopped
        stopCamera();
      }
    });

    // Friendly fallback message if getUserMedia unsupported
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      startBtn.disabled = true;
      logStatus('getUserMedia not supported in this browser.');
      const msg = document.createElement('div');
      msg.style.color = '#ffd2d2';
      msg.style.marginTop = '10px';
      msg.textContent = 'This browser does not support camera access. Use Chrome/Edge/Firefox on desktop.';
      document.querySelector('.left').appendChild(msg);
    }
  })();
  </script>
</body>
</html>
